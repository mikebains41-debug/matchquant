// --- Asian Handicap (fair odds) from scoreline probabilities ---
// Requires a scoreProb matrix: scoreProb[h][a] = P(H=h, A=a)
// If you only have sims, you can build scoreProb from sim counts.

function computeAsianHandicapFair(scoreProb, maxGoals = 10) {
  // goalDiffProb[d] where d = homeGoals - awayGoals (range -max..+max)
  const diffOffset = maxGoals;
  const diffProb = Array(2 * maxGoals + 1).fill(0);

  for (let h = 0; h <= maxGoals; h++) {
    for (let a = 0; a <= maxGoals; a++) {
      const p = (scoreProb[h] && scoreProb[h][a]) ? scoreProb[h][a] : 0;
      const d = h - a;
      if (d >= -maxGoals && d <= maxGoals) diffProb[d + diffOffset] += p;
    }
  }

  function sumDiffGreaterThan(x) {
    // P(diff > x)
    let s = 0;
    for (let d = x + 1; d <= maxGoals; d++) s += diffProb[d + diffOffset] || 0;
    return s;
  }
  function sumDiffGreaterOrEqual(x) {
    // P(diff >= x)
    let s = 0;
    for (let d = x; d <= maxGoals; d++) s += diffProb[d + diffOffset] || 0;
    return s;
  }
  function sumDiffLessThan(x) {
    // P(diff < x)
    let s = 0;
    for (let d = -maxGoals; d <= x - 1; d++) s += diffProb[d + diffOffset] || 0;
    return s;
  }
  function sumDiffLessOrEqual(x) {
    // P(diff <= x)
    let s = 0;
    for (let d = -maxGoals; d <= x; d++) s += diffProb[d + diffOffset] || 0;
    return s;
  }

  // For a given line L (home -0.25 etc), compute win/push/lose for HOME side.
  // Handles quarter-lines by splitting stake into two adjacent half-lines.
  function homeAhWinPushLose(line) {
    const isQuarter = Math.abs(line * 2 - Math.round(line * 2)) < 1e-9 && Math.abs(line * 1 - Math.round(line * 1)) > 1e-9;

    const evalHalf = (halfLine) => {
      // HOME bet at halfLine: outcome depends on diff + halfLine
      // If diff + halfLine > 0 => win
      // If diff + halfLine = 0 => push
      // If diff + halfLine < 0 => lose
      // diff is integer, so equality occurs when diff = -halfLine (halfLine is .0 or .5)
      let win = 0, push = 0, lose = 0;

      if (Math.abs(halfLine % 1) < 1e-9) {
        // integer line (e.g. -1, 0, +1)
        const t = -halfLine; // push when diff == t
        win = sumDiffGreaterThan(t);
        push = diffProb[t + diffOffset] || 0;
        lose = sumDiffLessThan(t);
      } else {
        // half line (e.g. -0.5, +1.5) => no push possible
        const t = -halfLine; // e.g. for -0.5, t=0.5. diff > 0.5 => diff>=1
        // win when diff > t
        // lose when diff < t
        // since diff is integer: diff > 0.5 => diff>=1, diff < 0.5 => diff<=0
        const ceilWin = Math.floor(t) + 1; // smallest integer > t
        const floorLose = Math.floor(t);    // largest integer < t (since t not integer)
        win = sumDiffGreaterOrEqual(ceilWin);
        push = 0;
        lose = sumDiffLessOrEqual(floorLose);
      }

      return { win, push, lose };
    };

    if (!isQuarter) {
      // if line is integer or half (multiples of 0.5)
      return evalHalf(line);
    }

    // quarter line: split into two half-lines
    // Example: -0.25 = half stake on 0 and -0.5
    //          +0.25 = half stake on 0 and +0.5
    const lower = Math.floor(line * 2) / 2;       // nearest lower half-step
    const upper = lower + 0.5;                    // next half-step

    const a = evalHalf(lower);
    const b = evalHalf(upper);

    // combine half stakes
    return {
      win: 0.5 * (a.win + b.win),
      push: 0.5 * (a.push + b.push),
      lose: 0.5 * (a.lose + b.lose)
    };
  }

  // Convert win/push/lose into "fair odds" for the home bet.
  // Fair decimal odds = 1 / P(win) when no push; with push, effective return differs.
  // We'll output:
  // - winProb (stake wins)
  // - loseProb (stake loses)
  // - pushProb (stake refunded)
  // - fairOdds "DNB-adjusted": 1 / (winProb / (winProb + loseProb))
  function fairOddsFromWPL(wpl) {
    const { win, push, lose } = wpl;
    const denom = win + lose;
    const dnbWinProb = denom > 0 ? win / denom : 0;
    const fairOdds = dnbWinProb > 0 ? (1 / dnbWinProb) : Infinity;
    return { win, push, lose, dnbWinProb, fairOdds };
  }

  const lines = [-2, -1.75, -1.5, -1.25, -1, -0.75, -0.5, -0.25, 0, +0.25, +0.5, +0.75, +1, +1.25, +1.5, +1.75, +2];

  const results = lines.map((L) => {
    const wpl = homeAhWinPushLose(L);
    const out = fairOddsFromWPL(wpl);
    return {
      line: L,
      home_win: out.win,
      home_push: out.push,
      home_lose: out.lose,
      home_fair: Number.isFinite(out.fairOdds) ? +out.fairOdds.toFixed(2) : null
    };
  });

  return results;
}
