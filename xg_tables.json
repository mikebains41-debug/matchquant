/* app.js ‚Äî MatchQuant (FIXED for partial xg_tables + full teams list)
   ‚úÖ Uses xg_tables.json when available
   ‚úÖ If a team is missing from xg_tables, it uses LEAGUE AVERAGE (not baseGoals)
   ‚úÖ Fixes team-name mismatches via aliases + normalized match
   ‚úÖ Removes ‚Äúeverything same‚Äù problem when at least one team has xG
*/
(() => {
  const $ = (id) => document.getElementById(id);

  const el = {
    league: $("leagueSelect"),
    home: $("homeTeam"),
    away: $("awayTeam"),
    sims: $("sims"),
    runBtn: $("runBtn"),
    results: $("results"),
    status: $("statusLine"),
  };

  // -------------------------
  // helpers
  // -------------------------
  const norm = (s) =>
    String(s || "")
      .trim()
      .toLowerCase()
      .replace(/\s+/g, " ")
      .replace(/[‚Äô']/g, "")
      .replace(/[.]/g, "");

  const clamp = (n, lo, hi) => Math.max(lo, Math.min(hi, n));

  function status(msg) {
    if (el.status) el.status.textContent = msg;
  }

  function setResults(html) {
    if (el.results) el.results.innerHTML = html;
  }

  function opt(v, t) {
    const o = document.createElement("option");
    o.value = v;
    o.textContent = t;
    return o;
  }

  function resetSelect(sel, placeholder, disabled = true) {
    if (!sel) return;
    sel.innerHTML = "";
    sel.appendChild(opt("", placeholder));
    sel.disabled = disabled;
  }

  function fillSelect(sel, values, placeholder) {
    resetSelect(sel, placeholder, false);
    values.forEach((v) => sel.appendChild(opt(v, v)));
    sel.disabled = false;
  }

  async function fetchJson(path) {
    const res = await fetch(path, { cache: "no-store" });
    if (!res.ok) throw new Error(`${path} failed (${res.status})`);
    return await res.json();
  }

  function findEngine() {
    return window.MQ && typeof window.MQ.predictMatchInternal === "function"
      ? window.MQ.predictMatchInternal
      : null;
  }

  function wireLeagueUpdate(updateTeams) {
    ["change", "input", "click", "touchend"].forEach((ev) => {
      el.league?.addEventListener(ev, () => {
        setTimeout(updateTeams, 0);
        setTimeout(updateTeams, 60);
        setTimeout(updateTeams, 160);
      });
    });
  }

  function applyAlias(aliasesByLeague, league, teamName) {
    const leagueAliases = aliasesByLeague?.[league];
    if (!leagueAliases) return teamName;
    const key = norm(teamName);
    return leagueAliases[key] || teamName;
  }

  // ----------------------------------------
  // KEY RESOLVER: exact -> alias -> norm scan
  // ----------------------------------------
  function resolveTeamKey(tableByLeague, aliases, league, teamName) {
    const table = tableByLeague?.[league];
    if (!table || typeof table !== "object") return teamName;

    // 1) exact
    if (table[teamName]) return teamName;

    // 2) alias (only if exists in table)
    const ali = applyAlias(aliases, league, teamName);
    if (ali && table[ali]) return ali;

    // 3) normalized scan
    const nt = norm(teamName);
    for (const k of Object.keys(table)) {
      if (String(k).startsWith("__")) continue;
      if (norm(k) === nt) return k;
    }

    return teamName;
  }

  // ----------------------------------------
  // LEAGUE AVERAGES (computed from xg_tables)
  // ----------------------------------------
  function computeLeagueAverages(xgTables, baseGoals = 1.35) {
    const out = {};
    for (const [league, table] of Object.entries(xgTables || {})) {
      if (!table || typeof table !== "object") continue;
      let sxg = 0,
        sxga = 0,
        n = 0;

      for (const [team, row] of Object.entries(table)) {
        if (!row || String(team).startsWith("__")) continue;
        const att = Number(row.att);
        const def = Number(row.def);
        if (Number.isFinite(att) && Number.isFinite(def)) {
          sxg += att;
          sxga += def;
          n++;
        }
      }

      if (n > 0) out[league] = { xg: sxg / n, xga: sxga / n };
      else out[league] = { xg: baseGoals, xga: baseGoals };
    }
    return out;
  }

  // ----------------------------------------
  // Read team xG if exists, else league avg
  // IMPORTANT: this is what fixes ‚Äúsame outputs‚Äù
  // ----------------------------------------
  function getTeamAttDefOrLeagueAvg(xgTables, leagueAvgs, league, teamKey, baseGoals = 1.35) {
    const row = xgTables?.[league]?.[teamKey];
    const att = Number(row?.att);
    const def = Number(row?.def);

    if (Number.isFinite(att) && Number.isFinite(def)) {
      return { att, def, found: true };
    }

    const avg = leagueAvgs?.[league] || { xg: baseGoals, xga: baseGoals };
    return { att: avg.xg, def: avg.xga, found: false };
  }

  // cards/corners row format:
  // { cards_for, cards_against, corners_for, corners_against }
  function getCardsCorners(cardsCorners, league, teamKey) {
    const row = cardsCorners?.[league]?.[teamKey];
    if (!row) return null;

    const cards_for = Number(row.cards_for);
    const cards_against = Number(row.cards_against);
    const corners_for = Number(row.corners_for);
    const corners_against = Number(row.corners_against);

    const ok =
      Number.isFinite(cards_for) &&
      Number.isFinite(cards_against) &&
      Number.isFinite(corners_for) &&
      Number.isFinite(corners_against);

    return ok ? { cards_for, cards_against, corners_for, corners_against } : null;
  }

  function fmtNum(x, d = 2) {
    if (x == null || !Number.isFinite(Number(x))) return "‚Äî";
    return Number(x).toFixed(d);
  }

  function toPct(x) {
    if (x == null || !Number.isFinite(Number(x))) return "‚Äî";
    return (Number(x) * 100).toFixed(1) + "%";
  }

  function fairOdds(p) {
    const pp = Number(p);
    if (!pp || !Number.isFinite(pp) || pp <= 0) return "‚Äî";
    return (1 / pp).toFixed(2);
  }

  // -------------------------
  // init
  // -------------------------
  async function init() {
    try {
      if (!el.league || !el.home || !el.away || !el.runBtn || !el.results) {
        throw new Error("Missing HTML IDs. index.html IDs must match app.js.");
      }

      resetSelect(el.league, "Select league", true);
      resetSelect(el.home, "Select home team", true);
      resetSelect(el.away, "Select away team", true);

      status("Loading data‚Ä¶");
      setResults(`<div style="opacity:.8">Loading‚Ä¶</div>`);

      const teamsByLeague = await fetchJson("./data/teams.json");

      // data containers
      let xgTables = {};
      let leagueStrength = {};
      let aliases = {};
      let cardsCorners = {};

      // load optional files
      try {
        xgTables = await fetchJson("./data/xg_tables.json");
      } catch {}
      try {
        leagueStrength = await fetchJson("./data/league_strength.json");
      } catch {}
      try {
        aliases = await fetchJson("./data/aliases.json");
      } catch {}
      try {
        cardsCorners = await fetchJson("./data/cards_corners_2025_2026.json");
      } catch {}

      // compute league averages ONCE from xg_tables
      const baseGoals = 1.35;
      const leagueAvgs = computeLeagueAverages(xgTables, baseGoals);

      const leagues = Object.keys(teamsByLeague || {}).sort();
      if (!leagues.length) throw new Error("teams.json loaded but has no leagues");

      resetSelect(el.league, "Select league", false);
      leagues.forEach((lg) => el.league.appendChild(opt(lg, lg)));
      el.league.disabled = false;

      const updateTeams = () => {
        const league = el.league.value;
        resetSelect(el.home, "Select home team", true);
        resetSelect(el.away, "Select away team", true);

        if (!league) return status("Pick a league.");

        const teams = teamsByLeague[league];
        if (!Array.isArray(teams) || !teams.length) return status(`No teams found for ${league}`);

        fillSelect(el.home, teams, "Select home team");
        fillSelect(el.away, teams, "Select away team");
        status(`Loaded ${teams.length} teams for ${league}`);
      };

      wireLeagueUpdate(updateTeams);

      el.runBtn.addEventListener("click", () => {
        const league = el.league.value;
        const home = el.home.value;
        const away = el.away.value;

        if (!league) return setResults(`<b>Pick a league first.</b>`);
        if (!home || !away) return setResults(`<b>Pick both teams.</b>`);
        if (home === away) return setResults(`<b>Teams must be different.</b>`);

        const engine = findEngine();
        if (!engine) {
          return setResults(
            `<b>Engine not found.</b><br>
             Make sure <code>engine.js</code> loads before <code>app.js</code> and exposes:<br>
             <code>window.MQ.predictMatchInternal</code>`
          );
        }

        // resolve lookup keys vs xg_tables
        const keyHome = resolveTeamKey(xgTables, aliases, league, home);
        const keyAway = resolveTeamKey(xgTables, aliases, league, away);

        // league multiplier: league_strength.json > __league_factor > 1.0
        let leagueMult = 1.0;
        if (typeof leagueStrength?.[league] === "number") leagueMult = leagueStrength[league];
        else if (typeof xgTables?.[league]?.__league_factor === "number")
          leagueMult = xgTables[league].__league_factor;

        const homeAdv = 1.10;
        const goalCap = 8;

        // üî• IMPORTANT FIX:
        // if team missing, we use LEAGUE AVG (from your xg_tables) not baseGoals=1.35
        const H = getTeamAttDefOrLeagueAvg(xgTables, leagueAvgs, league, keyHome, baseGoals);
        const A = getTeamAttDefOrLeagueAvg(xgTables, leagueAvgs, league, keyAway, baseGoals);

        // convert to multipliers around baseGoals
        const H_att = clamp(H.att / baseGoals, 0.6, 1.8);
        const H_def = clamp(H.def / baseGoals, 0.6, 1.8);
        const A_att = clamp(A.att / baseGoals, 0.6, 1.8);
        const A_def = clamp(A.def / baseGoals, 0.6, 1.8);

        const xgHome = baseGoals * H_att * A_def;
        const xgAway = baseGoals * A_att * H_def;

        // cards/corners (optional)
        const ccH = getCardsCorners(cardsCorners, league, keyHome);
        const ccA = getCardsCorners(cardsCorners, league, keyAway);

        const cardsHome = ccH && ccA ? (ccH.cards_for + ccA.cards_against) / 2 : null;
        const cardsAway = ccH && ccA ? (ccA.cards_for + ccH.cards_against) / 2 : null;

        const cornersHome = ccH && ccA ? (ccH.corners_for + ccA.corners_against) / 2 : null;
        const cornersAway = ccH && ccA ? (ccA.corners_for + ccH.corners_against) / 2 : null;

        const out = engine({
          leagueName: league,
          homeTeam: home,
          awayTeam: away,
          xgHome,
          xgAway,
          leagueMult,
          homeAdv,
          baseGoals,
          goalCap,
          sims: Number(el.sims?.value || 10000),
          cardsHome,
          cardsAway,
          cornersHome,
          cornersAway,
        });

        const x12 = out.x12 || {};
        const ou = out.ou25 || {};
        const btts = out.btts || {};
        const ml = out.mostLikely || {};
        const cards = out.cards || {};
        const corners = out.corners || {};

        setResults(`
          <div style="font-size:18px;font-weight:800;margin-bottom:6px;">
            ${home} vs ${away}
          </div>
          <div style="opacity:.85;margin-bottom:10px;">
            ${league} ‚Ä¢ ŒªH=${out.lamH.toFixed(2)} ‚Ä¢ ŒªA=${out.lamA.toFixed(2)}
          </div>

          <div class="kv">
            <span class="badge"><b>Most likely</b>: ${ml.h}-${ml.a} (${toPct(ml.p)})</span>
            <span class="badge"><b>O2.5</b>: ${toPct(ou.over)} (fair ${fairOdds(ou.over)})</span>
            <span class="badge"><b>U2.5</b>: ${toPct(ou.under)} (fair ${fairOdds(ou.under)})</span>
            <span class="badge"><b>BTTS Yes</b>: ${toPct(btts.yes)} (fair ${fairOdds(btts.yes)})</span>
            <span class="badge"><b>BTTS No</b>: ${toPct(btts.no)} (fair ${fairOdds(btts.no)})</span>
          </div>

          <hr style="border:0;border-top:1px solid rgba(255,255,255,.08);margin:12px 0;">

          <div style="font-weight:800;margin-bottom:6px;">1X2 (model)</div>
          <div style="line-height:1.6;">
            Home: <b>${toPct(x12.home)}</b> (fair <b>${fairOdds(x12.home)}</b>)<br>
            Draw: <b>${toPct(x12.draw)}</b> (fair <b>${fairOdds(x12.draw)}</b>)<br>
            Away: <b>${toPct(x12.away)}</b> (fair <b>${fairOdds(x12.away)}</b>)
          </div>

          <hr style="border:0;border-top:1px solid rgba(255,255,255,.08);margin:12px 0;">

          <div style="font-weight:800;margin-bottom:6px;">Cards & Corners (model)</div>
          <div style="line-height:1.6;">
            Team Cards (inputs): Home <b>${fmtNum(cardsHome, 2)}</b> ‚Ä¢ Away <b>${fmtNum(cardsAway, 2)}</b><br>
            Team Corners (inputs): Home <b>${fmtNum(cornersHome, 2)}</b> ‚Ä¢ Away <b>${fmtNum(cornersAway, 2)}</b><br><br>

            Total Cards Œª: <b>${fmtNum(cards.lambdaTotal, 2)}</b> ‚Ä¢ Most likely total: <b>${cards?.mostLikelyTotal?.k ?? "‚Äî"}</b><br>
            O4.5: <b>${toPct(cards?.ou45?.over)}</b> (fair <b>${fairOdds(cards?.ou45?.over)}</b>) ‚Ä¢
            U4.5: <b>${toPct(cards?.ou45?.under)}</b> (fair <b>${fairOdds(cards?.ou45?.under)}</b>)<br><br>

            Total Corners Œª: <b>${fmtNum(corners.lambdaTotal, 2)}</b> ‚Ä¢ Most likely total: <b>${corners?.mostLikelyTotal?.k ?? "‚Äî"}</b><br>
            O9.5: <b>${toPct(corners?.ou95?.over)}</b> (fair <b>${fairOdds(corners?.ou95?.over)}</b>) ‚Ä¢
            U9.5: <b>${toPct(corners?.ou95?.under)}</b> (fair <b>${fairOdds(corners?.ou95?.under)}</b>)
          </div>

          <div style="margin-top:12px;opacity:.75;font-size:12px;">
            xG keys: Home=<b>${keyHome}</b> (${H.found ? "FOUND ‚úÖ" : "LEAGUE AVG ‚ö†Ô∏è"}) ‚Ä¢
            Away=<b>${keyAway}</b> (${A.found ? "FOUND ‚úÖ" : "LEAGUE AVG ‚ö†Ô∏è"})<br/>
            att/def used: Home att=${fmtNum(H.att,2)} def=${fmtNum(H.def,2)} ‚Ä¢ Away att=${fmtNum(A.att,2)} def=${fmtNum(A.def,2)}<br/>
            League avg: att=${fmtNum(leagueAvgs?.[league]?.xg ?? baseGoals,2)} def=${fmtNum(leagueAvgs?.[league]?.xga ?? baseGoals,2)}
          </div>
        `);

        status("Done.");
      });

      status("Ready. Select league + teams, then Run.");
      setResults(`<div style="opacity:.85">Pick league + teams, then press <b>Run Prediction</b>.</div>`);
    } catch (e) {
      console.error(e);
      status("App error");
      setResults(`<b>Error:</b> ${String(e.message || e)}`);
    }
  }

  document.addEventListener("DOMContentLoaded", init);
})();
```Ó®Å0Ó®Ç
